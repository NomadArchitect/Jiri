{
  "comments": [
    {
      "key": {
        "uuid": "46990f5f_1c2a0c14",
        "filename": "cmd/jiri/resolve.go",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 5050
      },
      "writtenOn": "2019-04-11T16:24:05Z",
      "side": 1,
      "message": "Why do we need this option? Why not always enforce this when package lock is enabled?",
      "revId": "aa9e4b4c13a24a6d953c7034c14416552d6d96fc",
      "serverId": "ccdefb6c-23ea-33ff-848c-339fc6ca2269",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5919c6f_c86296cb",
        "filename": "cmd/jiri/resolve.go",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 12756
      },
      "writtenOn": "2019-04-11T17:43:50Z",
      "side": 1,
      "message": "If I land this change with this flag to true, the update-lockfile.sh will rewrite all lockfiles with new Version tag. It will cause merge conflicts with all rollers. \n\nThe version check is always enforced if they are available. This just control whether the \u0027jiri resolve\u0027 will output the package version tags in lockfile.",
      "parentUuid": "46990f5f_1c2a0c14",
      "revId": "aa9e4b4c13a24a6d953c7034c14416552d6d96fc",
      "serverId": "ccdefb6c-23ea-33ff-848c-339fc6ca2269",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed75831e_50a9e46a",
        "filename": "cmd/jiri/resolve.go",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 30867
      },
      "writtenOn": "2019-04-11T16:31:13Z",
      "side": 1,
      "message": "I think it\u0027s starting to make sense to have something like a project.Config struct that is effectively the resolveFlags struct which is used to populate the flags and is just passed into GenerateJiriLockFile -- or alternatively, is constructed based on the flags read.\n\nThis function call is getting hard to read and analyze for correctness, especially since the order of arguments does not match their order in the struct, and I seem to recall having either had this thought or commenting on it before in prior CLs touching this function.",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 216
      },
      "revId": "aa9e4b4c13a24a6d953c7034c14416552d6d96fc",
      "serverId": "ccdefb6c-23ea-33ff-848c-339fc6ca2269",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "714a65d5_7c913a0d",
        "filename": "cmd/jiri/resolve.go",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 12756
      },
      "writtenOn": "2019-04-11T17:43:50Z",
      "side": 1,
      "message": "Or maybe we can have a unified type that wraps around a map to store different flags for different jiri commands. It implements some interface like \"getBoolFlag(\"flag name\")\" etc. We can pass that wrapped map object to different callees.\n\nI changed the long args list into A ResolveConfig struct in latest patchset. I am reluctant to name it ProjectConfig since it is currently only used by \u0027jiri resolve\u0027. The ResolveConfig is defined in package \u0027project\u0027 instead of \u0027main\u0027, otherwise it will cause import cycles. Please let me know your thoughts.",
      "parentUuid": "ed75831e_50a9e46a",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 216
      },
      "revId": "aa9e4b4c13a24a6d953c7034c14416552d6d96fc",
      "serverId": "ccdefb6c-23ea-33ff-848c-339fc6ca2269",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa2518ef_280072aa",
        "filename": "cmd/jiri/resolve.go",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 30867
      },
      "writtenOn": "2019-04-11T17:49:51Z",
      "side": 1,
      "message": "Another common approach for configuration (that I forgot to mention, sorry!) is to declare an interface with function members that are expected to yield configuration parameters for that thing. So you could imagine an interface ResolveConfig with functions LockfilePath, LocalManifest, EnablePackageLock, etc. You could then attach functions to resolveFlags that implement this interface and have the function take that interface.\n\nThe approach described above I think is one of the cleaner solutions to this sort of problem -- the main package doesn\u0027t really need to know or fill in any types, and we don\u0027t have issues with effectively having flags in a non-main package.\n\nI think what you\u0027ve done is Just Fine(tm) for now, so I\u0027ll mark this comment resolved. I\u0027ll leave it up to you if you want to do the interface approach.",
      "parentUuid": "714a65d5_7c913a0d",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 216
      },
      "revId": "aa9e4b4c13a24a6d953c7034c14416552d6d96fc",
      "serverId": "ccdefb6c-23ea-33ff-848c-339fc6ca2269",
      "unresolved": false
    }
  ]
}