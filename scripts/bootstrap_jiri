#!/usr/bin/env bash
# Copyright 2015 The Vanadium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# bootstrap_jiri initializes a root directory for jiri.  The following
# directories and files will be created:
#   <root_dir>                         - root directory (picked by user)
#   <root_dir>/.jiri_root              - root metadata directory
#   <root_dir>/.jiri_root/bin/jiri     - jiri binary
#   <root_dir>/.jiri_root/scripts/jiri - jiri script
#
# The jiri sources are downloaded and built into a temp directory, which is
# always deleted when this script finishes.  The <root_dir> is deleted on any
# failure.

set -euf -o pipefail

readonly JIRI_GH_CONTENT="https://raw.githubusercontent.com/fuchsia-mirror/jiri"

# fatal prints an error message, followed by the usage string, and then exits.
fatal() {
  usage='

Usage:
   bootstrap_jiri <root_dir>

A typical bootstrap workflow looks like this:

$ curl -s ${JIRI_GH_CONTENT}/master/scripts/bootstrap_jiri | bash -s myroot
$ export PATH=myroot/.jiri_root/scripts:$PATH
$ cd myroot
$ jiri import manifest https://example.com/manifest
$ jiri update'
  echo "ERROR: $@${usage}" 1>&2
  exit 1
}

# toabs converts the possibly relative argument into an absolute path.  Run in a
# subshell to avoid changing the caller's working directory.
toabs() (
  cd $(dirname $1)
  echo ${PWD}/$(basename $1)
)

# Check the <root_dir> argument is supplied.
if [[ $# -ne 1 ]]; then
  fatal "need <root_dir> argument"
fi

# Ensure <root_dir> doesn't already exist: this is important since we trap this script and
# rm -rf <root_dir> if anything fails.
mkdir -p "$(dirname $1)"
readonly ROOT_DIR="$(toabs $1)"
if [[ -e "${ROOT_DIR}" ]]; then
  fatal "${ROOT_DIR} already exists"
fi

# Check that go is on the PATH.
if ! go version >& /dev/null ; then
  fatal 'ERROR: "go" tool not found, see https://golang.org/doc/install'
fi

# Remove the root_dir if this script fails so as to not leave the environment in a strange half-state.
trap "rm -rf ${ROOT_DIR}" INT TERM EXIT

# Make the output directories.
readonly BIN_DIR="${ROOT_DIR}/.jiri_root/bin"
readonly SCRIPTS_DIR="${ROOT_DIR}/.jiri_root/scripts"
mkdir -p "${BIN_DIR}" "${SCRIPTS_DIR}"

# Determine and validate the version of jiri.
readonly TARGET="$(uname | tr '[:upper:]' '[:lower:]')-amd64"
readonly VERSION="$(curl -s ${JIRI_GH_CONTENT}/master/prebuilt/versions/${TARGET}/version.sha | tr -d '[[:space:]]')"
if [[ ! "${VERSION}" =~ "[0-9a-f]{40}" ]]; then
	# This might happen if there's a server error, or maybe ${TARGET}/version.sha doesn't exist.
	echo "Retrieved jiri version does not match expected pattern:" 1>&2
	echo "${VERSION}" 1>&2
	echo "" 1>&2
	echo "Maybe ${TARGET} isn't supported?" 1>&2
	exit 1
fi

# Download the jiri binary.
curl -o "${BIN_DIR}/jiri" "https://fuchsia-build.storage.googleapis.com/jiri/${TARGET}/${VERSION}"

# Download the jiri wrapper script.
curl -o "${SCRIPTS_DIR}/jiri" "${JIRI_GH_CONTENT}/${VERSION}/scripts/jiri"

echo "Please add ${SCRIPTS_DIR} to your PATH"
trap - EXIT
